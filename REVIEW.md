# Code Review

## Critical Issues

1. **Logging call raises formatting exception**
   `ChihirosDataUpdateCoordinator._async_handle_unavailable` logs the Bluetooth address with a format string that expects two arguments (`"%s: CHIHIROS device unavailable: %s"`) but only supplies one. Python's logging module will raise a `TypeError` for "not enough arguments for format string" the first time that path executes, preventing the expected critical log from being emitted and cluttering the log with stack traces. 【F:custom_components/chihiros/coordinator.py†L71-L77】

2. **Fallback coordinator parent breaks CLI/test usage**
   The `try/except ModuleNotFoundError` block is meant to allow importing the integration when Home Assistant isn't installed (for example, by the provided CLI tooling). However, the fallback `_FakeParent` doesn't define an `__init__`. When Home Assistant is missing, `CoordinatorParent` becomes `_FakeParent`, so the call to `super().__init__(hass, _LOGGER, ble_device.address, ...)` invokes `object.__init__`, which rejects the positional arguments and raises `TypeError`. As a result, simply constructing `ChihirosDataUpdateCoordinator` fails outside Home Assistant, defeating the purpose of the guard. 【F:custom_components/chihiros/coordinator.py†L8-L59】

3. **Auto-mode enable command encodes the wrong payload**
   When `BaseDevice.enable_auto_mode` calls `create_switch_to_auto_mode_command`, it builds a packet with mode `0x05` and parameters `[0x12, 0xFF, 0xFF]` because `_create_command_encoding` is invoked as `_create_command_encoding(90, 5, msg_id, [18, 255, 255])`. 【F:custom_components/chihiros/chihiros_led_control/commands.py†L130-L132】 The captured traffic shows that the real app switches to auto mode by sending command `0xA5` with mode `0x20` and three parameters `0x02, 0x00, 0x00` (message `a50108019820020000b2`). 【F:captures/export.jsonl†L454】 The integration therefore sends a completely different opcode and parameter set, so enabling auto mode from Home Assistant will silently fail. Every automation that calls `enable_auto_mode` (coordinator, CLI, and services) is affected because they all rely on this helper. 【F:custom_components/chihiros/chihiros_led_control/device/base_device.py†L240-L261】

4. **Auto-schedule encoding diverges from captured protocol (add & delete)**
   `create_add_auto_setting_command` always appends five trailing `0xFF` bytes and expects a `165/0xA5` command with mode `0x19` plus 14 parameters. 【F:custom_components/chihiros/chihiros_led_control/commands.py†L79-L122】 The captured packets that add or update schedules use mode `0x1B` and only six parameters with no `0xFF` padding (e.g., `a5010b01991b027f0101017287`). 【F:captures/export.jsonl†L458】 Because `create_delete_auto_setting_command` simply calls the same helper, the delete service inherits the same incorrect opcode and oversized payload. The CLI (`add_setting`, `add_rgb_setting`, `remove_setting`) and any Home Assistant service invoking these helpers will therefore write packets the light does not understand. 【F:custom_components/chihiros/chihiros_led_control/device/base_device.py†L186-L249】

5. **Resetting schedules reuses the wrong command template**
   The integration resets schedules by emitting the same `0x5A/0x90` command template as the auto-mode toggle, just with parameters `[5, 255, 255]`. 【F:custom_components/chihiros/chihiros_led_control/commands.py†L125-L127】 In contrast, the capture shows two distinct `0xA5` commands with mode `0x04` and single-byte parameters `0x04` and `0x05` (`a501060195040493`, `a501060196040591`). 【F:captures/export.jsonl†L437-L441】 The current implementation therefore never sends the device's actual reset opcodes, leaving previously programmed schedules intact even though `reset_settings` reports success. 【F:custom_components/chihiros/chihiros_led_control/device/base_device.py†L240-L254】

6. **Manual brightness command uses an unseen mode/value pair**
   `create_manual_setting_command` formats a `0x5A` command in mode `0x07` with `[color, brightness]`. 【F:custom_components/chihiros/chihiros_led_control/commands.py†L68-L76】 The sniffed writes to the UART characteristic all use mode `0x04` with a single-parameter payload instead (example: `5a01060192040191`). 【F:captures/export.jsonl†L425】 Because the constructed packet differs in both mode and parameter count from the app's traffic, issuing `set_brightness` or `set_color_brightness` from Home Assistant is expected to fail. The loop that iterates over `_colors` magnifies the problem by trying to send one malformed command per color channel. 【F:custom_components/chihiros/chihiros_led_control/device/base_device.py†L144-L185】

## Suggestions

* Consider updating the placeholder text/docstring at the top of `coordinator.py` ("Keymitt BLE") to reflect the actual integration name. 【F:custom_components/chihiros/coordinator.py†L1-L4】
* Running `pytest` collects zero tests (`collected 0 items`), so there is currently no automated coverage validating the command encoders against the captured protocol. Adding targeted unit tests would help prevent future regressions. 【199283†L1-L7】

### Capture comparison follow-up

* The project does subscribe to the Nordic UART notify characteristic and will log every payload (for example, the 7-byte `5b 04 03 03 f3 fe ad` frame) at debug level, but it never interprets those short acknowledgements. Other variants (`… af`, `… aa`, `… a9`, etc.) and the 34-byte blobs `5b 1f 1e 16 f3 fe 4a 17 23 4d …` captured in `export.frames.clean.hex` are therefore just emitted to the log with no follow-up handling. 【F:custom_components/chihiros/chihiros_led_control/device/base_device.py†L357-L444】【F:captures/export.frames.clean.hex†L289-L341】
* The doser helpers explicitly emit 0x5B totals probes and only treat 15-byte notifications with eight payload bytes as meaningful data. The sample notifications `5b 01 0a 00 01 22 02 58 08 04 01 63 00 d2 7f` / `… e1 7f` match that shape and would be decoded into four channel totals. Shorter 7-byte ACKs and longer 34-byte payloads are ignored because `parse_totals_frame` requires exactly eight parameters after the mode byte, so none of the additional variants from the capture end up being parsed into channel totals. 【F:custom_components/chihiros/chihiros_doser_control/protocol.py†L68-L191】【F:custom_components/chihiros/chihiros_doser_control/__init__.py†L201-L315】【F:captures/export.frames.clean.hex†L289-L341】
* Digging into the 34-byte frames shows they are Xiaomi MiBeacon service data advertisements: the payload starts with the BLE AD structure header `0x1E 0x16 0xF3 0xFE`, meaning 30 bytes of Service Data for UUID `0xFEF3`. The next bytes encode MiBeacon metadata—frame control `0x174A`, product IDs such as `0x4D23`, frame counters (`0x33`, `0x5A`, etc.), and the device MACs (`54:31:11:32:B0:93`, `5A:4A:11:32:B2:21`, …)—followed by 15–16 bytes of encrypted event data plus the integrity tag. Because the integration lacks the Xiaomi key material, these MiBeacon telemetry broadcasts are logged and discarded. 【F:captures/export.frames.clean.hex†L289-L341】【F:captures/frames.csv†L55-L76】
* The MiBeacon frame-control word `0x174A` sets bit `0x0400`, advertising that the appended event payload is encrypted. Xiaomi encrypts these beacons with 128-bit AES-CCM: the 12-byte nonce is built from the device MAC (little-endian), product identifier, and the frame counter byte (e.g., `0x33`), and the ciphertext is followed by a 4-byte message integrity code. Without the per-device bind key negotiated during Xiaomi pairing, the 16-byte tail `ba 6b d5 … 83 39` cannot be decrypted or authenticated, which is why the integration can only log it. 【F:captures/export.frames.clean.hex†L289-L341】【F:captures/frames.csv†L55-L76】

### Obtaining the Xiaomi bind key

* Pair the doser/light with the official Mi Home app so that Xiaomi's backend provisions a bind key for the device. Once the device shows up in your Mi Home account, query the Xiaomi cloud `bluetooth/keys` endpoint with your account credentials to retrieve the key material. The open-source `miio` utilities ship a `miblecloud.py` helper for this purpose: run `python3 -m miio.miblecloud --email <mi-account> --password <app-password> --get-key <did>` (substituting the device's Mi ID) and the script will print the 32-character bind key. 【F:REVIEW.md†L99-L106】
* Logging into the Chihiros-branded mobile app with your Chihiros username/password does **not** expose the Xiaomi bind key—the Chihiros cloud account is separate from Xiaomi's Mi Account system and cannot authenticate against `api.io.mi.com`. To obtain the key you must still log in with a Mi Account in Mi Home (or via the Xiaomi REST API) and bind the device there so that the Xiaomi backend generates the key material tied to your Mi credentials.
* If you prefer not to use the Python helper, you can reproduce the same call with `curl`: authenticate against `https://api.io.mi.com/app/login` to obtain an `ssecurity`/`serviceToken`, then POST to `https://api.io.mi.com/app/bluetooth/keys` with the JSON body `{ "dids": ["<did>"] }`. The response contains a `bindKey` field that you can feed into the integration's MiBeacon decryptor. 【F:REVIEW.md†L107-L110】

